# -*- coding: utf-8 -*-
"""Copy of Stock_Market_Prediction_Model_Creation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b3BFm8xDtwQ4A6G5QCQf1ukmEBf3YJBR
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

start = '2024-01-01'
end = '2025-07-01'
stock = '^NSEI'

data = yf.download(stock, start, end)

data.reset_index(inplace=True)

data

from matplotlib import pyplot as plt
data['Open'].plot(kind='line', figsize=(8, 4), title='Open')
plt.gca().spines[['top', 'right']].set_visible(False)

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['Date']
  ys = series['Open']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = data.sort_values('Date', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('Date')
_ = plt.ylabel('Open')

ma_100_days = data.Close.rolling(100).mean()

plt.figure(figsize=(8,6))
plt.plot(ma_100_days, 'r')
plt.plot(data.Close, 'g')
plt.show()

ma_200_days = data.Close.rolling(200).mean()

plt.figure(figsize=(8,6))
plt.plot(ma_100_days, 'r')
plt.plot(ma_200_days,'b')
plt.plot(data.Close,'g')
plt.show()

data.dropna(inplace=True)

data_train = pd.DataFrame(data.Close[0: int(len(data)*0.80)])
data_test = pd.DataFrame(data.Close[int(len(data)*0.80): len(data)])

data_train.shape[0]

data_test.shape[0]

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))

data_train_scale = scaler.fit_transform(data_train)

x = []
y = []

for i in range(100, data_train_scale.shape[0]):
    x.append(data_train_scale[i-100:i])
    y.append(data_train_scale[i,0])

x, y = np.array(x), np.array(y)

from keras.layers import Dense, Dropout, LSTM
from keras.models import Sequential

model = Sequential()
model.add(LSTM(units = 50, activation = 'relu', return_sequences = True,
               input_shape = ((x.shape[1],1))))
model.add(Dropout(0.2))

model.add(LSTM(units = 60, activation='relu', return_sequences = True))
model.add(Dropout(0.3))

model.add(LSTM(units = 80, activation = 'relu', return_sequences = True))
model.add(Dropout(0.4))

model.add(LSTM(units = 120, activation = 'relu'))
model.add(Dropout(0.5))

model.add(Dense(units =1))

model.compile(optimizer = 'adam', loss = 'mean_squared_error')

model.fit(x,y, epochs = 50, batch_size =32, verbose =1)

model.summary()

pas_100_days = data_train.tail(100)

data_test = pd.concat([pas_100_days, data_test], ignore_index=True)

data_test_scale  =  scaler.fit_transform(data_test)

x = []
y = []

for i in range(100, data_test_scale.shape[0]):
    x.append(data_test_scale[i-100:i])
    y.append(data_test_scale[i,0])
x, y = np.array(x), np.array(y)

y_predict = model.predict(x)

scale =1/scaler.scale_

y_predict = y_predict*scale

y = y*scale

plt.figure(figsize=(10,8))
plt.plot(y_predict, 'r', label = 'Predicted Price')
plt.plot(y, 'g', label = 'Original Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

model.save('Stock Predictions Model.keras')

!pip install backtesting yfinance

import yfinance as yf

data = yf.download('^NSEI', start='2025-01-01', end='2025-07-01')

!pip install backtesting

import pandas as pd
import yfinance as yf
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
from backtesting.test import SMA  # using the SMA helper

# 1) Download NSE Index (^NSEI)
data = yf.download('^NSEI',
                   start='2025-01-01',
                   end='2025-07-01',
                   group_by='column',
                   progress=False)

# 2) Flatten columns if MultiIndex slipped in
if isinstance(data.columns, pd.MultiIndex):
    for lvl in range(data.columns.nlevels):
        if data.columns.get_level_values(lvl).nunique() == 1:
            data.columns = data.columns.droplevel(lvl)
            break
    if isinstance(data.columns, pd.MultiIndex):
        data.columns = ['_'.join(map(str, col)).strip() for col in data.columns]

# 3) Conform to Backtesting.py schema
if 'Adj Close' in data.columns and 'Close' in data.columns:
    data['Close'] = data['Adj Close']
if 'Adj Close' in data.columns:
    data = data.drop(columns=['Adj Close'])

need = ['Open', 'High', 'Low', 'Close', 'Volume']
for col in ['Open', 'High', 'Low', 'Close']:
    if col not in data.columns:
        raise ValueError(f"Missing required column: {col}")
if 'Volume' not in data.columns:
    data['Volume'] = 0  # fake if not available

data = data[need].dropna()

# 4) Define strategy (SMA crossover)
class SmaCross(Strategy):
    n1 = 10
    n2 = 20
    def init(self):
        close = self.data.Close
        self.sma1 = self.I(SMA, close, self.n1)
        self.sma2 = self.I(SMA, close, self.n2)
    def next(self):
        if crossover(self.sma1, self.sma2):
            self.buy()
        elif crossover(self.sma2, self.sma1):
            self.sell()

# 5) Run backtest
bt = Backtest(data, SmaCross, cash=10_000, commission=.002, exclusive_orders=True)

# Store stats in 'output'
output = bt.run()

# Print performance metrics
print(output)

# Plot equity curve & trades
bt.plot()

output